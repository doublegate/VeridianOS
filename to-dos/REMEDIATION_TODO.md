# Remediation TODO - Phases 0-4 Gaps

**Purpose**: Genuine gaps and partially-implemented items from Phases 0-4 that should be addressed
**Generated**: 2026-02-15
**Project Version**: v0.4.1
**Scope**: Only items from Phases 0-4 (Phases 5-6 are future work)

---

## Summary

This file was generated by auditing all 17 TODO files against the actual codebase. It captures
items that were supposed to be completed as part of Phases 0-4 but are either missing, partially
implemented, or only exist as type definitions/stubs without real functionality.

## Critical Priority

Items that could cause runtime failures or represent genuine functional gaps.

### C-001: UEFI/Multiboot2 Boot Protocol Support (Phase 1)
**Status**: Not implemented
**Impact**: Kernel can only boot via custom bootloader; no standard boot protocol support
**Details**: PHASE1_TODO.md lists UEFI boot stub (PE32+ header, UEFI protocol handling, memory map
retrieval, graphics output) and Multiboot2 support for all architectures as Phase 1 tasks. None of
these exist. The kernel uses its own minimal boot path.
**Assessment**: Acceptable for development (QEMU direct kernel boot works), but a genuine gap for
any real hardware deployment. This is a large effort that was implicitly deferred.
**Action**: Reclassify as Phase 5/6 future work or create a dedicated boot modernization effort.

### C-002: AArch64 GIC Interrupt Controller (Phase 1/2)
**Status**: Not implemented
**Impact**: AArch64 has no hardware interrupt controller support
**Details**: AARCH64-FIXES-TODO.md identifies GICv2/v3 initialization as needed. The kernel boots
and runs on AArch64 using timer polling rather than interrupt-driven preemption. No
`arch/aarch64/gic.rs` file exists.
**Assessment**: AArch64 boots to BOOTOK and passes all 27 tests, but true preemptive scheduling
on AArch64 hardware requires GIC support.
**Action**: Implement GICv2/v3 initialization for QEMU virt machine.

### C-003: x86_64 APIC Full Implementation (Phase 1)
**Status**: Partial -- timer.rs references APIC but full APIC module is not present
**Impact**: Interrupt routing limited to PIC; no MSI/MSI-X, no multi-core interrupt distribution
**Details**: PHASE1_TODO.md lists APIC support and MSI/MSI-X as Phase 1 items. `arch/x86_64/timer.rs`
has APIC references but there is no dedicated APIC module with full local APIC + I/O APIC init.
**Assessment**: The PIC-based approach works for single-core QEMU testing. SMP interrupt distribution
requires a proper APIC implementation.
**Action**: Create `arch/x86_64/apic.rs` with local APIC + I/O APIC initialization.

### C-004: RISC-V PLIC Interrupt Controller (Phase 1)
**Status**: Not implemented
**Impact**: RISC-V relies on SBI calls for timer; no general interrupt routing
**Details**: PHASE1_TODO.md lists PLIC support for RISC-V. The kernel uses SBI timer but has no
Platform-Level Interrupt Controller driver.
**Assessment**: Boot and basic scheduling work via SBI timer. External device interrupts require PLIC.
**Action**: Implement PLIC driver for RISC-V QEMU virt machine.

## High Priority

Items that represent significant functional gaps but do not cause crashes.

### H-001: User-Space Pointer Validation in Syscalls (Phase 1)
**Status**: Partially implemented
**Impact**: System call handlers have validation functions but coverage may be incomplete
**Details**: PHASE1_TODO.md marks "User space pointer validation" and "Safe memory copying from/to
user" as incomplete. Files `syscall/mod.rs`, `syscall/process.rs`, `syscall/filesystem.rs` have
`validate_user_ptr` functions. Coverage across all syscall paths needs verification.
**Action**: Audit all syscall handlers to ensure consistent pointer validation.

### H-002: High-Resolution Timer Management (Phase 1)
**Status**: Not implemented beyond basic tick timer
**Impact**: No high-res timers, one-shot timers, or tickless operation
**Details**: PHASE1_TODO.md Section 8 lists high-resolution timers, periodic timers, one-shot timers,
time keeping, and tickless operation as Phase 1 items. The kernel has a basic 10ms tick timer per
arch via `PlatformTimer` trait but none of the advanced timer features.
**Assessment**: Basic scheduling works with the tick timer. Advanced timer features are needed for
real-time workloads and power management.
**Action**: Implement timer wheel or hierarchical timer queue.

### H-003: IRQ Object Abstraction (Phase 1)
**Status**: Not implemented
**Impact**: No generic interrupt routing or user-space interrupt delivery
**Details**: PHASE1_TODO.md lists "IRQ object abstraction", "Interrupt routing", and "User-space
delivery" as generic interrupt interface items. Interrupt handling is currently architecture-specific
with no unified abstraction layer.
**Action**: Create `kernel/src/irq/` module with generic IRQ abstraction.

### H-004: Process Server Full Implementation (Phase 2)
**Status**: Exists as service but Phase 2 TODO items unchecked
**Impact**: Process enumeration and resource limit enforcement may be incomplete
**Details**: `services/process_server.rs` exists with process server implementation, but PHASE2_TODO
marks process creation, termination, enumeration, and resource limits as unchecked under
"User-Space Runtime > Process Management".
**Assessment**: The process server exists and is functional. The unchecked items in PHASE2_TODO
reflect that the TODO was never updated, not that the work is missing.
**Action**: Verify process server covers enumeration and resource limit APIs; update TODO.

### H-005: Thread Creation User-Space API (Phase 2)
**Status**: Kernel-side exists; user-space API partial
**Impact**: No user-space thread creation or TLS setup API
**Details**: PHASE2_TODO marks thread creation API, TLS, synchronization primitives, and scheduling
hints as unchecked. Kernel has `thread_api.rs` and process thread management. User-space API
wrappers in SDK exist as type definitions.
**Assessment**: Kernel-side is complete. User-space API is types-only (requires actual user-space
runtime which does not exist yet as a separate binary).
**Action**: Document as requiring user-space runtime; partial gap.

### H-006: Standard Library Foundation (Phase 2)
**Status**: Type definitions only; no actual user-space runtime
**Impact**: No real Vec, HashMap, String implementations for user-space processes
**Details**: PHASE2_TODO marks heap allocator interface, collections, and sync primitives under
"Standard Library Foundation" as unchecked. The kernel uses `alloc` crate internally. User-space
std implementation exists as SDK type definitions only.
**Assessment**: This requires a real user-space environment to implement. The kernel side (syscall
wrappers, memory allocation) is in place. The actual user-space standard library cannot exist
until user-space processes run independently.
**Action**: Reclassify as future work dependent on actual user-space binary execution.

### H-007: Missing Driver Framework SDK Items (Phase 2)
**Status**: Partially implemented
**Impact**: DMA buffer management and MMIO access utilities exist but may not be fully wired
**Details**: PHASE2_TODO marks "DMA buffer management", "Interrupt handling framework", and "MMIO
access utilities" under Driver SDK as unchecked. `net/dma_pool.rs` has DMA buffer management.
`drivers/` has PCI config space access. Interrupt framework is architecture-specific.
**Assessment**: Individual components exist but a unified Driver SDK package is not assembled.
**Action**: Verify DMA, interrupt, and MMIO utilities are accessible from driver crates.

### H-008: NVMe Driver (Phase 2)
**Status**: Type definitions and queue structures only
**Impact**: No actual NVMe hardware interaction
**Details**: `drivers/nvme.rs` exists with NVMe data structures and queue pair definitions.
PHASE2_TODO lists NVMe as a core driver. The implementation has type definitions but no actual
hardware I/O (no MMIO register access, no interrupt handling).
**Assessment**: This is a stub/framework. Real NVMe support requires hardware interaction which
is deferred until hardware testing.
**Action**: Mark as framework-only; full implementation requires hardware/emulation testing.

### H-009: AHCI/SATA Driver (Phase 2)
**Status**: Type definitions only in `drivers/storage.rs`
**Impact**: No SATA disk access
**Details**: `drivers/storage.rs` has ATA/IDE definitions. No AHCI controller initialization,
command submission, or interrupt handling.
**Assessment**: Similar to NVMe -- framework exists, hardware interaction deferred.
**Action**: Mark as framework-only.

### H-010: Secure Boot Verification Chain (Phase 3)
**Status**: Framework with type definitions
**Impact**: No actual UEFI signature verification or measured boot
**Details**: `security/boot.rs` exists with secure boot types and verification framework.
PHASE3_TODO marks all secure boot items as unchecked. The implementation has structures for
verification but no actual PE/COFF parsing or certificate chain validation.
**Assessment**: The framework types allow compilation and boot sequence hooks. Actual crypto
verification of boot images is not implemented.
**Action**: Document as framework-only; real implementation requires UEFI boot support (C-001).

### H-011: TLS 1.3 Implementation (Phase 3)
**Status**: Not implemented
**Impact**: No encrypted network communication
**Details**: PHASE3_TODO lists TLS 1.3, certificate management, and OCSP under "Secure Communication".
No TLS module exists in the codebase.
**Assessment**: The crypto primitives (ChaCha20-Poly1305, Ed25519, X25519, SHA-256) needed for TLS
are all implemented. The TLS protocol state machine and record layer are not.
**Action**: Reclassify as future work; requires real network stack integration.

## Medium Priority

Items that are partial or could be improved but do not block core functionality.

### M-001: Interrupt Capability Type (Phase 1)
**Status**: Not implemented
**Impact**: No capability-based interrupt management
**Details**: PHASE1_TODO.md lists "Interrupt caps" as a capability type that was deferred. The
capability system supports IPC, Memory, Process, and Thread types but not Interrupt capabilities.
**Action**: Add InterruptCapability type to capability system when IRQ abstraction (H-003) is built.

### M-002: Direct Context Switch on IPC Send (Phase 1)
**Status**: Not implemented
**Impact**: IPC uses cooperative scheduling rather than direct switch to receiver
**Details**: PHASE1_TODO lists "Direct context switch on send" under synchronous IPC as unchecked.
IPC currently signals the scheduler to wake the receiver rather than directly switching.
**Assessment**: Performance is already <1us. Direct switching is an optimization.
**Action**: Consider during Phase 5 performance optimization.

### M-003: CPU-Local IPC Caching (Phase 1)
**Status**: Not implemented
**Impact**: Minor performance impact on IPC lookups
**Details**: PHASE1_TODO lists "CPU-local caching" under IPC performance optimization. The global
registry uses O(1) lookup. CPU-local caching would reduce cache line contention.
**Action**: Defer to Phase 5 performance optimization.

### M-004: Storage Drivers - virtio-blk (Phase 2)
**Status**: Not implemented
**Impact**: No block device emulation in QEMU
**Details**: PHASE2_TODO lists virtio-blk driver for QEMU. `drivers/virtio_net.rs` exists for
networking but no virtio-blk. Would enable filesystem testing in QEMU.
**Action**: Implement when persistent storage testing is needed.

### M-005: Input Drivers (Phase 2)
**Status**: Not implemented
**Impact**: No keyboard/mouse input
**Details**: PHASE2_TODO lists PS/2 keyboard, PS/2 mouse, USB HID, and virtio-input drivers.
The shell exists but only processes hardcoded/simulated input during boot tests.
**Assessment**: Input drivers require a functional display or serial terminal. The kernel shell
works via serial console commands during boot testing.
**Action**: Implement PS/2 keyboard driver when interactive testing begins.

### M-006: Time Service (Phase 2)
**Status**: Partial -- clock functions exist, no timer service
**Impact**: No user-facing timer creation or alarm service
**Details**: PHASE2_TODO lists system time management, timer creation, and alarm service under
"Time Service". The kernel has `arch/timer.rs` PlatformTimer for internal scheduling. No
user-facing timer creation API.
**Action**: Create timer service syscall wrappers.

### M-007: Log Service (Phase 2)
**Status**: Kernel logging exists via kprintln; no structured log service
**Impact**: No log rotation, remote logging, or service log aggregation
**Details**: PHASE2_TODO lists kernel log collection, service log aggregation, log rotation, and
remote logging. The kernel has serial output and `kprintln!` macro. The audit system in
`security/audit.rs` provides structured event logging but is security-focused, not general.
**Action**: Create general-purpose structured logging service.

### M-008: IPC High-Level Framework Gaps (Phase 2)
**Status**: Partial
**Impact**: No IDL compiler, stub generation, or message bus broadcast
**Details**: PHASE2_TODO lists IDL compiler, stub generation, marshalling, named endpoints,
broadcast support, and service discovery under "High-Level IPC". The `ipc/rpc.rs` module
provides RPC-style communication. Named endpoints exist in the registry. IDL compiler and
code generation do not exist.
**Assessment**: Manual RPC works. IDL/codegen is a nice-to-have for large-scale service development.
**Action**: Defer IDL compiler to future work; document existing RPC patterns.

### M-009: Async I/O Framework (Phase 2)
**Status**: Type definitions only
**Impact**: No io_uring-like interface or async event loop
**Details**: PHASE2_TODO lists event loop, async IPC wrappers, Future/Promise support, and
io_uring-like interface. `pkg/async_types.rs` has AsyncRuntime trait and TaskHandle types.
No actual async runtime implementation.
**Assessment**: The kernel uses cooperative scheduling; true async I/O requires user-space runtime.
**Action**: Reclassify as Phase 5/6 optimization work.

### M-010: MAC Policy Binary Generation and Runtime Updates (Phase 3)
**Status**: Parser exists; binary generation not implemented
**Impact**: Policies can be parsed but not compiled to efficient binary format
**Details**: `security/mac/parser.rs` has policy language parsing. `security/mac/mod.rs` has
policy enforcement. PHASE3_TODO marks "Binary policy generation" and "Runtime updates" as
unchecked. Policies work in text-parsed form.
**Assessment**: Text-based policy enforcement works. Binary policy compilation is an optimization.
**Action**: Consider for Phase 5 performance work.

### M-011: Security Sandboxing (Phase 3)
**Status**: Partial -- capabilities provide process isolation; no namespace isolation
**Impact**: No Linux-style namespace isolation or seccomp filtering
**Details**: PHASE3_TODO lists process sandboxing, namespace isolation, resource limits, and
seccomp-like filtering. Capability-based isolation provides the primary sandbox. Namespaces and
seccomp-like filtering are not implemented.
**Assessment**: Capability-based security provides stronger isolation than namespaces in many
threat models. Namespace isolation is a convenience feature for container compatibility.
**Action**: Implement when container support (Phase 6) begins.

### M-012: File Integrity Monitoring (Phase 3)
**Status**: Not implemented
**Impact**: No runtime integrity checking of files
**Details**: PHASE3_TODO lists file integrity monitoring, runtime integrity, configuration monitoring,
and drift detection under "Integrity Monitoring". The audit system can log file access events but
does not compute or verify integrity hashes at runtime.
**Action**: Implement IMA-like integrity measurement when VFS is extended with persistent storage.

### M-013: CFI and Exploit Mitigation (Phase 3)
**Status**: Partial -- ASLR, DEP/NX, guard pages, W^X, Spectre barriers exist
**Impact**: No CFI, CET, or pointer authentication
**Details**: `security/memory_protection.rs` implements ASLR, DEP/NX, W^X enforcement, Spectre
barriers, and KPTI. PHASE3_TODO additionally lists CFI, CET, and pointer authentication which
are not implemented.
**Assessment**: The implemented mitigations cover the most critical attack vectors. CFI/CET/PAC
require compiler and hardware support that is complex to implement in a custom OS.
**Action**: Defer CFI/CET to Phase 5/6; document PAC as AArch64-specific future work.

### M-014: Security Fuzzing Infrastructure (Phase 3)
**Status**: Framework exists but not actively used
**Impact**: No active fuzz testing in CI
**Details**: `security/fuzzing.rs` has syscall fuzzing infrastructure. PHASE3_TODO marks fuzzing
as Phase 3 testing. The framework exists but is not integrated into CI/CD.
**Action**: Integrate fuzzing into CI when automated testing is unblocked.

## Low Priority

Nice-to-have items or documentation gaps.

### L-001: Phase 0 Goals Checkbox Inconsistency
**Status**: Minor doc error
**Impact**: None -- cosmetic
**Details**: PHASE0_TODO.md line 28 has "Set up debugging and development tools" unchecked despite
being fully implemented (GDB scripts, VS Code tasks, etc. all present).
**Action**: Check the checkbox. (Addressed in this audit.)

### L-002: E1000 Network Driver (Phase 2)
**Status**: Not implemented
**Impact**: No Intel E1000 NIC emulation; virtio-net is used instead
**Details**: PHASE2_TODO lists Intel E1000 driver. `drivers/e1000.rs` exists but may be minimal.
The kernel uses `drivers/virtio_net.rs` for QEMU networking.
**Assessment**: VirtIO-Net is the better QEMU driver. E1000 is mainly useful for hardware testing.
**Action**: Low priority; VirtIO-Net covers QEMU use case.

### L-003: Job Control in Shell (Phase 2)
**Status**: Not implemented
**Impact**: No background jobs or job control in shell
**Details**: PHASE2_TODO lists job control under Basic Shell. The shell (`services/shell/`) has
command parsing and built-in commands but no background job management or signal-based job control.
**Assessment**: Shell is primarily for boot-time diagnostics. Full job control requires signal
infrastructure and foreground/background process groups.
**Action**: Implement when interactive shell use becomes a priority.

### L-004: Documentation Phase 2-4 Sections (Documentation TODO)
**Status**: Marked as incomplete in DOCUMENTATION_TODO.md
**Impact**: Developer documentation gaps
**Details**: DOCUMENTATION_TODO marks Phase 2 documentation (driver development guide, VFS docs,
shell usage), Phase 3 documentation (security config, MAC policy docs, crypto API), and Phase 4
documentation (package format spec, SDK docs) as all unchecked.
**Assessment**: The codebase has extensive inline documentation and doc comments. Standalone guide
documents for these phases were not created.
**Action**: Create standalone guides as needed; inline docs are adequate for development.

### L-005: ISSUES_TODO.md Stale Open Issues
**Status**: Outdated issue tracker
**Impact**: Confusing status for anyone reading the file
**Details**: ISSUES_TODO.md lists ISSUE-0012 (x86_64 boot hang), ISSUE-0017 (AArch64 bootstrap),
and ISSUE-0018 (RISC-V frame allocator lock) as open/critical. All three have been resolved:
- ISSUE-0012: Fixed in v0.3.0/v0.3.5
- ISSUE-0017: Fixed -- AArch64 completes bootstrap and reaches BOOTOK
- ISSUE-0018: Fixed in v0.3.5 (frame allocator memory region fix)
**Action**: Update ISSUES_TODO.md to mark these resolved. (Addressed in this audit.)

### L-006: AARCH64-FIXES-TODO.md Stale
**Status**: Outdated -- all listed issues resolved
**Impact**: Confusing for developers
**Details**: AARCH64-FIXES-TODO.md lists 6 priority levels of fixes, all marked unchecked. The
actual AArch64 implementation now boots to Stage 6 BOOTOK with all 27 tests passing.
**Assessment**: This file predates the v0.3.x series fixes. All critical items are resolved.
**Action**: Mark items as resolved or archive the file. (Addressed in this audit.)

### L-007: Release Roadmap Completely Outdated (RELEASE_TODO.md)
**Status**: Shows v0.3.0 as next release with Q1 2026 target
**Impact**: Confusing timeline; actual version is v0.4.1
**Details**: RELEASE_TODO.md lists v0.3.0 through v1.0.0 with target dates. The actual project
is at v0.4.1. Release history from v0.3.1 through v0.4.1 is not recorded.
**Action**: Update release roadmap with actual release history. (Addressed in this audit.)

### L-008: QA Metrics Not Populated
**Status**: All metrics show "Not measured" or placeholder values
**Impact**: No quality tracking
**Details**: QA_TODO.md has tables for code quality, defect, and performance metrics all showing
"Not measured". The project actually has zero warnings, SAFETY coverage >100%, etc.
**Action**: Populate QA metrics with actual values.

---

## Deferred Items (Not Gaps -- Correctly Deferred to Phase 5/6)

These items appear in Phase 0-4 TODOs but were correctly deferred to future phases:

- **UEFI boot**: Requires significant hardware-specific work (Phase 5/6)
- **Real hardware driver testing**: NVMe, AHCI on real hardware (Phase 5/6)
- **User-space standard library**: Requires real process isolation and independent binaries (Phase 6)
- **Container runtime / namespaces**: Phase 6 feature
- **GUI toolkit and desktop applications**: Phase 6 feature
- **Full async I/O runtime**: Phase 5/6 optimization
- **IDL compiler for IPC**: Developer tooling, Phase 5/6

---

## Statistics

| Priority | Count |
|----------|-------|
| Critical | 4 |
| High | 11 |
| Medium | 14 |
| Low | 8 |
| **Total** | **37** |

**Note**: Many of these "gaps" are items that were listed optimistically in early TODO files and
were correctly deprioritized during development. The actual kernel is functional, boots on all
three architectures, and passes all tests. The critical and high items represent genuine areas
where additional work would meaningfully improve the system.
