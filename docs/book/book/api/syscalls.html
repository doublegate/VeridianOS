<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>System Call API - VeridianOS Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to VeridianOS development">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../book-theme/veridian.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VeridianOS Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/doublegate/VeridianOS" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="system-call-api"><a class="header" href="#system-call-api">System Call API</a></h1>
<p>This document provides the complete system call interface for VeridianOS applications. All user-space programs interact with the kernel through these system calls.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<h3 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h3>
<ol>
<li><strong>Capability-Based Security</strong>: All system calls validate capabilities</li>
<li><strong>Minimal Interface</strong>: Small number of orthogonal system calls</li>
<li><strong>Architecture Independence</strong>: Consistent interface across all platforms</li>
<li><strong>Performance</strong>: Optimized for common use cases</li>
<li><strong>Type Safety</strong>: Strong typing through user-space wrappers</li>
</ol>
<h3 id="calling-convention"><a class="header" href="#calling-convention">Calling Convention</a></h3>
<p>System calls use standard calling conventions for each architecture:</p>
<ul>
<li><strong>x86_64</strong>: <code>syscall</code> instruction, arguments in registers</li>
<li><strong>AArch64</strong>: <code>svc</code> instruction with immediate value</li>
<li><strong>RISC-V</strong>: <code>ecall</code> instruction</li>
</ul>
<h2 id="core-system-calls"><a class="header" href="#core-system-calls">Core System Calls</a></h2>
<h3 id="process-management"><a class="header" href="#process-management">Process Management</a></h3>
<h4 id="sys_exit-1"><a class="header" href="#sys_exit-1"><code>SYS_EXIT</code> (1)</a></h4>
<p>Exit the current process.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_exit(exit_code: i32) -&gt; !;
<span class="boring">}</span></code></pre></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>exit_code</code>: Process exit code</li>
</ul>
<p><strong>Returns:</strong> Never returns</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    syscall1(SYS_EXIT, 0);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_process_create-20"><a class="header" href="#sys_process_create-20"><code>SYS_PROCESS_CREATE</code> (20)</a></h4>
<p>Create a new process.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_process_create(
    binary: *const u8,
    binary_len: usize,
    args: *const *const u8,
    args_len: usize,
    capabilities: *const Capability,
    cap_count: usize,
) -&gt; Result&lt;ProcessId, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>binary</code>: Pointer to executable binary</li>
<li><code>binary_len</code>: Length of binary in bytes</li>
<li><code>args</code>: Array of argument strings</li>
<li><code>args_len</code>: Number of arguments</li>
<li><code>capabilities</code>: Array of capabilities to grant</li>
<li><code>cap_count</code>: Number of capabilities</li>
</ul>
<p><strong>Returns:</strong> Process ID or error</p>
<h4 id="sys_process_start-21"><a class="header" href="#sys_process_start-21"><code>SYS_PROCESS_START</code> (21)</a></h4>
<p>Start execution of a created process.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_process_start(process_id: ProcessId) -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_process_wait-22"><a class="header" href="#sys_process_wait-22"><code>SYS_PROCESS_WAIT</code> (22)</a></h4>
<p>Wait for process completion.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_process_wait(
    process_id: ProcessId,
    timeout_ns: u64,
) -&gt; Result&lt;ProcessExitInfo, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="thread-management"><a class="header" href="#thread-management">Thread Management</a></h3>
<h4 id="sys_thread_create-25"><a class="header" href="#sys_thread_create-25"><code>SYS_THREAD_CREATE</code> (25)</a></h4>
<p>Create a new thread within the current process.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_thread_create(
    entry_point: usize,
    stack_base: usize,
    stack_size: usize,
    arg: usize,
) -&gt; Result&lt;ThreadId, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>entry_point</code>: Thread entry function address</li>
<li><code>stack_base</code>: Base address of thread stack</li>
<li><code>stack_size</code>: Size of stack in bytes</li>
<li><code>arg</code>: Argument passed to entry function</li>
</ul>
<h4 id="sys_thread_exit-26"><a class="header" href="#sys_thread_exit-26"><code>SYS_THREAD_EXIT</code> (26)</a></h4>
<p>Exit the current thread.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_thread_exit(exit_code: i32) -&gt; !;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_thread_join-27"><a class="header" href="#sys_thread_join-27"><code>SYS_THREAD_JOIN</code> (27)</a></h4>
<p>Wait for thread completion.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_thread_join(
    thread_id: ThreadId,
    timeout_ns: u64,
) -&gt; Result&lt;i32, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<h4 id="sys_mmap-4"><a class="header" href="#sys_mmap-4"><code>SYS_MMAP</code> (4)</a></h4>
<p>Map memory into the process address space.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_mmap(
    addr: usize,
    length: usize,
    prot: ProtectionFlags,
    flags: MapFlags,
    capability: Capability,
    offset: usize,
) -&gt; Result&lt;usize, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>addr</code>: Preferred address (0 for any)</li>
<li><code>length</code>: Size to map in bytes</li>
<li><code>prot</code>: Protection flags (read/write/execute)</li>
<li><code>flags</code>: Mapping flags (private/shared/anonymous)</li>
<li><code>capability</code>: Memory capability for validation</li>
<li><code>offset</code>: Offset into backing object</li>
</ul>
<p><strong>Protection Flags:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProtectionFlags(u32);

impl ProtectionFlags {
    pub const NONE: u32 = 0;
    pub const READ: u32 = 1 &lt;&lt; 0;
    pub const WRITE: u32 = 1 &lt;&lt; 1;
    pub const EXEC: u32 = 1 &lt;&lt; 2;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Map Flags:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MapFlags(u32);

impl MapFlags {
    pub const PRIVATE: u32 = 1 &lt;&lt; 0;
    pub const SHARED: u32 = 1 &lt;&lt; 1;
    pub const ANONYMOUS: u32 = 1 &lt;&lt; 2;
    pub const FIXED: u32 = 1 &lt;&lt; 3;
    pub const POPULATE: u32 = 1 &lt;&lt; 4;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_munmap-5"><a class="header" href="#sys_munmap-5"><code>SYS_MUNMAP</code> (5)</a></h4>
<p>Unmap memory from the process address space.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_munmap(addr: usize, length: usize) -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_mprotect-6"><a class="header" href="#sys_mprotect-6"><code>SYS_MPROTECT</code> (6)</a></h4>
<p>Change protection on memory region.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_mprotect(
    addr: usize,
    length: usize,
    prot: ProtectionFlags,
) -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="inter-process-communication"><a class="header" href="#inter-process-communication">Inter-Process Communication</a></h3>
<h4 id="sys_ipc_endpoint_create-10"><a class="header" href="#sys_ipc_endpoint_create-10"><code>SYS_IPC_ENDPOINT_CREATE</code> (10)</a></h4>
<p>Create an IPC endpoint for receiving messages.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_ipc_endpoint_create() -&gt; Result&lt;(EndpointId, IpcCapability), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Returns:</strong> Endpoint ID and capability for the endpoint</p>
<h4 id="sys_ipc_channel_create-11"><a class="header" href="#sys_ipc_channel_create-11"><code>SYS_IPC_CHANNEL_CREATE</code> (11)</a></h4>
<p>Create a channel between two endpoints.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_ipc_channel_create(
    endpoint1: EndpointId,
    endpoint2: EndpointId,
    cap1: IpcCapability,
    cap2: IpcCapability,
) -&gt; Result&lt;ChannelId, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_ipc_send-12"><a class="header" href="#sys_ipc_send-12"><code>SYS_IPC_SEND</code> (12)</a></h4>
<p>Send a message through a channel.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_ipc_send(
    channel_id: ChannelId,
    message: *const u8,
    message_len: usize,
    capability: Option&lt;Capability&gt;,
    channel_cap: IpcCapability,
) -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>channel_id</code>: Target channel</li>
<li><code>message</code>: Message data pointer</li>
<li><code>message_len</code>: Message length (≤4KB)</li>
<li><code>capability</code>: Optional capability to transfer</li>
<li><code>channel_cap</code>: Capability for the channel</li>
</ul>
<h4 id="sys_ipc_receive-13"><a class="header" href="#sys_ipc_receive-13"><code>SYS_IPC_RECEIVE</code> (13)</a></h4>
<p>Receive a message from an endpoint.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_ipc_receive(
    endpoint_id: EndpointId,
    buffer: *mut u8,
    buffer_len: usize,
    timeout_ns: u64,
    endpoint_cap: IpcCapability,
) -&gt; Result&lt;IpcReceiveResult, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<p><strong>Returns:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct IpcReceiveResult {
    pub sender: ProcessId,
    pub message_len: usize,
    pub capability: Option&lt;Capability&gt;,
    pub reply_token: Option&lt;ReplyToken&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_ipc_call-14"><a class="header" href="#sys_ipc_call-14"><code>SYS_IPC_CALL</code> (14)</a></h4>
<p>Send message and wait for reply.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_ipc_call(
    channel_id: ChannelId,
    request: *const u8,
    request_len: usize,
    response: *mut u8,
    response_len: usize,
    timeout_ns: u64,
    capability: Option&lt;Capability&gt;,
    channel_cap: IpcCapability,
) -&gt; Result&lt;IpcCallResult, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_ipc_reply-15"><a class="header" href="#sys_ipc_reply-15"><code>SYS_IPC_REPLY</code> (15)</a></h4>
<p>Reply to a received message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_ipc_reply(
    reply_token: ReplyToken,
    response: *const u8,
    response_len: usize,
    capability: Option&lt;Capability&gt;,
) -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="capability-management"><a class="header" href="#capability-management">Capability Management</a></h3>
<h4 id="sys_capability_create-30"><a class="header" href="#sys_capability_create-30"><code>SYS_CAPABILITY_CREATE</code> (30)</a></h4>
<p>Create a new capability.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_capability_create(
    object_type: ObjectType,
    object_id: ObjectId,
    rights: Rights,
    parent_capability: Capability,
) -&gt; Result&lt;Capability, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_capability_derive-31"><a class="header" href="#sys_capability_derive-31"><code>SYS_CAPABILITY_DERIVE</code> (31)</a></h4>
<p>Create a restricted version of an existing capability.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_capability_derive(
    parent: Capability,
    new_rights: Rights,
) -&gt; Result&lt;Capability, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_capability_revoke-32"><a class="header" href="#sys_capability_revoke-32"><code>SYS_CAPABILITY_REVOKE</code> (32)</a></h4>
<p>Revoke a capability and all its derivatives.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_capability_revoke(capability: Capability) -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_capability_validate-33"><a class="header" href="#sys_capability_validate-33"><code>SYS_CAPABILITY_VALIDATE</code> (33)</a></h4>
<p>Validate that a capability grants specific rights.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_capability_validate(
    capability: Capability,
    required_rights: Rights,
) -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="io-operations"><a class="header" href="#io-operations">I/O Operations</a></h3>
<h4 id="sys_read-2"><a class="header" href="#sys_read-2"><code>SYS_READ</code> (2)</a></h4>
<p>Read data from a capability-protected resource.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_read(
    capability: Capability,
    buffer: *mut u8,
    count: usize,
    offset: u64,
) -&gt; Result&lt;usize, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_write-3"><a class="header" href="#sys_write-3"><code>SYS_WRITE</code> (3)</a></h4>
<p>Write data to a capability-protected resource.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_write(
    capability: Capability,
    buffer: *const u8,
    count: usize,
    offset: u64,
) -&gt; Result&lt;usize, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h3 id="time-and-scheduling"><a class="header" href="#time-and-scheduling">Time and Scheduling</a></h3>
<h4 id="sys_clock_get-40"><a class="header" href="#sys_clock_get-40"><code>SYS_CLOCK_GET</code> (40)</a></h4>
<p>Get current time.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_clock_get(clock_id: ClockId) -&gt; Result&lt;Timespec, SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_nanosleep-41"><a class="header" href="#sys_nanosleep-41"><code>SYS_NANOSLEEP</code> (41)</a></h4>
<p>Sleep for specified duration.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_nanosleep(duration: *const Timespec) -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h4 id="sys_yield-42"><a class="header" href="#sys_yield-42"><code>SYS_YIELD</code> (42)</a></h4>
<p>Voluntarily yield CPU to other threads.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sys_yield() -&gt; Result&lt;(), SyscallError&gt;;
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="system-call-errors"><a class="header" href="#system-call-errors">System Call Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// System call error codes
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u32)]
pub enum SyscallError {
    /// Success (not an error)
    Success = 0,
    
    /// Invalid parameter
    InvalidParameter = 1,
    
    /// Permission denied
    PermissionDenied = 2,
    
    /// Resource not found
    NotFound = 3,
    
    /// Resource already exists
    AlreadyExists = 4,
    
    /// Out of memory
    OutOfMemory = 5,
    
    /// Resource busy
    Busy = 6,
    
    /// Operation timed out
    Timeout = 7,
    
    /// Resource exhausted
    ResourceExhausted = 8,
    
    /// Invalid capability
    InvalidCapability = 9,
    
    /// Operation interrupted
    Interrupted = 10,
    
    /// Invalid address
    InvalidAddress = 11,
    
    /// Buffer too small
    BufferTooSmall = 12,
    
    /// Operation not supported
    NotSupported = 13,
    
    /// Invalid system call number
    InvalidSyscall = 14,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="architecture-specific-details"><a class="header" href="#architecture-specific-details">Architecture-Specific Details</a></h2>
<h3 id="x86_64-system-call-interface"><a class="header" href="#x86_64-system-call-interface">x86_64 System Call Interface</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// x86_64 system call with 0 arguments
#[inline]
pub unsafe fn syscall0(number: usize) -&gt; usize {
    let ret: usize;
    asm!(
        "syscall",
        in("rax") number,
        out("rax") ret,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    ret
}

/// x86_64 system call with 1 argument
#[inline]
pub unsafe fn syscall1(number: usize, arg1: usize) -&gt; usize {
    let ret: usize;
    asm!(
        "syscall",
        in("rax") number,
        in("rdi") arg1,
        out("rax") ret,
        out("rcx") _,
        out("r11") _,
        options(nostack),
    );
    ret
}

/// Additional syscall2, syscall3, etc. follow same pattern
<span class="boring">}</span></code></pre></pre>
<h3 id="aarch64-system-call-interface"><a class="header" href="#aarch64-system-call-interface">AArch64 System Call Interface</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// AArch64 system call with 0 arguments
#[inline]
pub unsafe fn syscall0(number: usize) -&gt; usize {
    let ret: usize;
    asm!(
        "svc #0",
        in("x8") number,
        out("x0") ret,
        options(nostack),
    );
    ret
}

/// AArch64 system call with 1 argument
#[inline]
pub unsafe fn syscall1(number: usize, arg1: usize) -&gt; usize {
    let ret: usize;
    asm!(
        "svc #0",
        in("x8") number,
        in("x0") arg1,
        out("x0") ret,
        options(nostack),
    );
    ret
}
<span class="boring">}</span></code></pre></pre>
<h3 id="risc-v-system-call-interface"><a class="header" href="#risc-v-system-call-interface">RISC-V System Call Interface</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// RISC-V system call with 0 arguments
#[inline]
pub unsafe fn syscall0(number: usize) -&gt; usize {
    let ret: usize;
    asm!(
        "ecall",
        in("a7") number,
        out("a0") ret,
        options(nostack),
    );
    ret
}

/// RISC-V system call with 1 argument
#[inline]
pub unsafe fn syscall1(number: usize, arg1: usize) -&gt; usize {
    let ret: usize;
    asm!(
        "ecall",
        in("a7") number,
        in("a0") arg1,
        out("a0") ret,
        options(nostack),
    );
    ret
}
<span class="boring">}</span></code></pre></pre>
<h2 id="user-space-library"><a class="header" href="#user-space-library">User-Space Library</a></h2>
<h3 id="high-level-wrappers"><a class="header" href="#high-level-wrappers">High-Level Wrappers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// High-level process creation
pub fn create_process(
    binary: &amp;[u8],
    args: &amp;[&amp;str],
    capabilities: &amp;[Capability],
) -&gt; Result&lt;ProcessId, Error&gt; {
    // Convert strings to C-style arrays
    let c_args: Vec&lt;*const u8&gt; = args.iter()
        .map(|s| s.as_ptr())
        .collect();
    
    let result = unsafe {
        syscall6(
            SYS_PROCESS_CREATE,
            binary.as_ptr() as usize,
            binary.len(),
            c_args.as_ptr() as usize,
            c_args.len(),
            capabilities.as_ptr() as usize,
            capabilities.len(),
        )
    };
    
    if result &amp; (1 &lt;&lt; 63) != 0 {
        Err(Error::from_syscall_error(result))
    } else {
        Ok(result as ProcessId)
    }
}

/// High-level memory mapping
pub fn mmap(
    addr: Option&lt;usize&gt;,
    length: usize,
    prot: ProtectionFlags,
    flags: MapFlags,
    capability: Option&lt;Capability&gt;,
    offset: usize,
) -&gt; Result&lt;*mut u8, Error&gt; {
    let addr = addr.unwrap_or(0);
    let cap = capability.unwrap_or(Capability::null());
    
    let result = unsafe {
        syscall6(
            SYS_MMAP,
            addr,
            length,
            prot.0 as usize,
            flags.0 as usize,
            cap.token as usize,
            offset,
        )
    };
    
    if result &amp; (1 &lt;&lt; 63) != 0 {
        Err(Error::from_syscall_error(result))
    } else {
        Ok(result as *mut u8)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="fast-path-optimizations"><a class="header" href="#fast-path-optimizations">Fast Path Optimizations</a></h3>
<ol>
<li><strong>Register-Based Small Messages</strong>: Messages ≤64 bytes transferred in registers</li>
<li><strong>Capability Caching</strong>: Validated capabilities cached for repeated use</li>
<li><strong>Batch Operations</strong>: Multiple operations combined when possible</li>
<li><strong>Zero-Copy IPC</strong>: Large messages use shared memory</li>
</ol>
<h3 id="benchmark-results"><a class="header" href="#benchmark-results">Benchmark Results</a></h3>
<ul>
<li><strong>Context Switch</strong>: ~8μs average</li>
<li><strong>Small IPC Message</strong>: ~0.8μs average</li>
<li><strong>Large IPC Transfer</strong>: ~3.2μs average</li>
<li><strong>Memory Allocation</strong>: ~0.6μs average</li>
<li><strong>Capability Validation</strong>: ~0.2μs average</li>
</ul>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Use High-Level Wrappers</strong>: Safer than raw system calls</li>
<li><strong>Validate Capabilities Early</strong>: Check capabilities before operations</li>
<li><strong>Handle Errors Gracefully</strong>: All system calls can fail</li>
<li><strong>Prefer Async Operations</strong>: Better scalability than blocking</li>
<li><strong>Batch Small Operations</strong>: Reduce system call overhead</li>
<li><strong>Use Shared Memory</strong>: For large data transfers</li>
</ol>
<p>This system call interface provides secure, efficient access to VeridianOS kernel services while maintaining the capability-based security model.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../api/kernel.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../api/drivers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../api/kernel.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../api/drivers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
