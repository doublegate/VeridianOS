<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Process Management - VeridianOS Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to VeridianOS development">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../book-theme/veridian.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VeridianOS Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/doublegate/VeridianOS" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="process-management"><a class="header" href="#process-management">Process Management</a></h1>
<p>VeridianOS implements a lightweight process model with capability-based isolation and a multi-class scheduler designed for performance, scalability, and real-time responsiveness.</p>
<h2 id="process-model"><a class="header" href="#process-model">Process Model</a></h2>
<h3 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h3>
<ol>
<li><strong>Lightweight Threads</strong>: Minimal overhead thread creation and switching</li>
<li><strong>Capability-Based Isolation</strong>: Process isolation through capabilities, not permissions</li>
<li><strong>Zero-Copy Communication</strong>: Efficient inter-process data transfer</li>
<li><strong>Real-Time Support</strong>: Predictable scheduling for time-critical tasks</li>
<li><strong>Scalability</strong>: Support for 1000+ concurrent processes</li>
</ol>
<h3 id="thread-control-block-tcb"><a class="header" href="#thread-control-block-tcb">Thread Control Block (TCB)</a></h3>
<p>Each thread is represented by a compact control block:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct ThreadControlBlock {
    // Identity
    tid: ThreadId,
    pid: ProcessId,
    name: [u8; 32],
    
    // Scheduling
    state: ThreadState,
    priority: Priority,
    sched_class: SchedClass,
    cpu_affinity: CpuSet,
    
    // Timing
    cpu_time: u64,
    last_run: Instant,
    time_slice: Duration,
    deadline: Option&lt;Instant&gt;,
    
    // Memory
    address_space: AddressSpace,
    kernel_stack: VirtAddr,
    user_stack: VirtAddr,
    
    // CPU Context
    saved_context: Context,
    
    // IPC
    ipc_state: IpcState,
    message_queue: MessageQueue,
    
    // Capabilities
    cap_space: CapabilitySpace,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="thread-states"><a class="header" href="#thread-states">Thread States</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ThreadState {
    /// Currently executing on CPU
    Running,
    
    /// Ready to run, waiting for CPU
    Ready,
    
    /// Blocked waiting for resource
    Blocked(BlockReason),
    
    /// Suspended by debugger/admin
    Suspended,
    
    /// Terminated, awaiting cleanup
    Terminated,
}

#[derive(Debug, Clone, Copy)]
pub enum BlockReason {
    /// Waiting for IPC message
    IpcReceive(EndpointId),
    
    /// Waiting for IPC reply
    IpcReply(ReplyToken),
    
    /// Waiting for memory allocation
    Memory,
    
    /// Sleeping for specified duration
    Sleep(Instant),
    
    /// Waiting for child process
    WaitChild(ProcessId),
    
    /// Waiting for I/O completion
    Io(IoHandle),
    
    /// Waiting for mutex/semaphore
    Synchronization(SyncHandle),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cpu-context-management"><a class="header" href="#cpu-context-management">CPU Context Management</a></h2>
<h3 id="architecture-specific-context"><a class="header" href="#architecture-specific-context">Architecture-Specific Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// x86_64 context structure
#[repr(C)]
pub struct Context {
    // General purpose registers
    rax: u64, rbx: u64, rcx: u64, rdx: u64,
    rsi: u64, rdi: u64, rbp: u64, rsp: u64,
    r8: u64,  r9: u64,  r10: u64, r11: u64,
    r12: u64, r13: u64, r14: u64, r15: u64,
    
    // Control registers
    rip: u64,         // Instruction pointer
    rflags: u64,      // Flags register
    cr3: u64,         // Page table base
    
    // Segment registers
    cs: u16, ds: u16, es: u16, fs: u16, gs: u16, ss: u16,
    
    // Extended state
    fpu_state: Option&lt;Box&lt;FpuState&gt;&gt;,
    avx_state: Option&lt;Box&lt;AvxState&gt;&gt;,
}

// AArch64 context structure
#[cfg(target_arch = "aarch64")]
#[repr(C)]
pub struct Context {
    // General purpose registers
    x: [u64; 31],     // x0-x30
    sp: u64,          // Stack pointer
    pc: u64,          // Program counter
    pstate: u64,      // Processor state
    
    // System registers
    ttbr0_el1: u64,   // Translation table base
    ttbr1_el1: u64,
    tcr_el1: u64,     // Translation control
    
    // FPU/SIMD state
    fpu_state: Option&lt;Box&lt;FpuState&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="context-switching"><a class="header" href="#context-switching">Context Switching</a></h3>
<p>Fast context switching is critical for performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Switch between threads on same CPU
pub fn context_switch(from: &amp;mut ThreadControlBlock, to: &amp;ThreadControlBlock) -&gt; Result&lt;()&gt; {
    // 1. Save current thread state
    save_context(&amp;mut from.saved_context)?;
    
    // 2. Update scheduling metadata
    from.last_run = Instant::now();
    from.cpu_time += from.last_run.duration_since(from.last_scheduled);
    
    // 3. Switch address space if needed
    if from.pid != to.pid {
        switch_address_space(&amp;to.address_space)?;
    }
    
    // 4. Restore new thread state
    restore_context(&amp;to.saved_context)?;
    
    // 5. Update current thread pointer
    set_current_thread(to.tid);
    
    Ok(())
}

/// Architecture-specific context save/restore
#[cfg(target_arch = "x86_64")]
unsafe fn save_context(context: &amp;mut Context) -&gt; Result&lt;()&gt; {
    asm!(
        "mov {rax}, rax",
        "mov {rbx}, rbx",
        "mov {rcx}, rcx",
        // ... save all registers
        rax = out(reg) context.rax,
        rbx = out(reg) context.rbx,
        rcx = out(reg) context.rcx,
        // ... other register outputs
    );
    
    // Save FPU state if used
    if thread_uses_fpu() {
        save_fpu_state(&amp;mut context.fpu_state)?;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="scheduling-system"><a class="header" href="#scheduling-system">Scheduling System</a></h2>
<h3 id="multi-level-feedback-queue-mlfq"><a class="header" href="#multi-level-feedback-queue-mlfq">Multi-Level Feedback Queue (MLFQ)</a></h3>
<p>VeridianOS uses a sophisticated scheduler with multiple priority levels:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Scheduler {
    /// Real-time run queue (priorities 0-99)
    rt_queue: RealTimeQueue,
    
    /// Interactive run queue (priorities 100-139)
    interactive_queue: InteractiveQueue,
    
    /// Normal time-sharing queue (priorities 140-179)
    normal_queue: NormalQueue,
    
    /// Batch processing queue (priorities 180-199)
    batch_queue: BatchQueue,
    
    /// Idle tasks (priority 200)
    idle_queue: IdleQueue,
    
    /// Currently running thread
    current: Option&lt;ThreadId&gt;,
    
    /// Scheduling statistics
    stats: SchedulerStats,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="scheduling-classes"><a class="header" href="#scheduling-classes">Scheduling Classes</a></h3>
<h4 id="real-time-scheduling-0-99"><a class="header" href="#real-time-scheduling-0-99">Real-Time Scheduling (0-99)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl RealTimeQueue {
    /// Add real-time thread with deadline
    pub fn enqueue(&amp;mut self, thread: ThreadId, deadline: Instant) -&gt; Result&lt;()&gt; {
        // Earliest Deadline First (EDF) scheduling
        let insertion_point = self.queue.binary_search_by_key(&amp;deadline, |t| t.deadline)?;
        self.queue.insert(insertion_point, RtTask { thread, deadline });
        Ok(())
    }
    
    /// Get next real-time thread to run
    pub fn dequeue(&amp;mut self) -&gt; Option&lt;ThreadId&gt; {
        // Always run earliest deadline first
        self.queue.pop_front().map(|task| task.thread)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="interactive-scheduling-100-139"><a class="header" href="#interactive-scheduling-100-139">Interactive Scheduling (100-139)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl InteractiveQueue {
    /// Add interactive thread with boost
    pub fn enqueue(&amp;mut self, thread: ThreadId, boost: u8) -&gt; Result&lt;()&gt; {
        let effective_priority = self.base_priority + boost;
        self.priority_queues[effective_priority as usize].push_back(thread);
        Ok(())
    }
    
    /// Boost priority for I/O bound tasks
    pub fn io_boost(&amp;mut self, thread: ThreadId) {
        if let Some(task) = self.find_task(thread) {
            task.boost = (task.boost + 5).min(20);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="time-sharing-scheduling-140-179"><a class="header" href="#time-sharing-scheduling-140-179">Time-Sharing Scheduling (140-179)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl NormalQueue {
    /// Standard round-robin with aging
    pub fn enqueue(&amp;mut self, thread: ThreadId) -&gt; Result&lt;()&gt; {
        let priority = self.calculate_priority(thread);
        self.priority_queues[priority].push_back(thread);
        Ok(())
    }
    
    /// Age threads to prevent starvation
    pub fn age_threads(&amp;mut self) {
        for (priority, queue) in self.priority_queues.iter_mut().enumerate() {
            if priority &gt; 0 {
                // Move long-waiting threads to higher priority
                while let Some(thread) = queue.pop_front() {
                    if self.should_age(thread) {
                        self.priority_queues[priority - 1].push_back(thread);
                    } else {
                        queue.push_back(thread);
                        break;
                    }
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cpu-affinity-and-load-balancing"><a class="header" href="#cpu-affinity-and-load-balancing">CPU Affinity and Load Balancing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LoadBalancer {
    /// Per-CPU run queue lengths
    cpu_loads: [AtomicU32; MAX_CPUS],
    
    /// Last balance timestamp
    last_balance: Instant,
    
    /// Balancing interval
    balance_interval: Duration,
}

impl LoadBalancer {
    /// Balance load across CPUs
    pub fn balance(&amp;mut self) -&gt; Result&lt;()&gt; {
        let now = Instant::now();
        if now.duration_since(self.last_balance) &lt; self.balance_interval {
            return Ok(());
        }
        
        // Find most and least loaded CPUs
        let (max_cpu, max_load) = self.find_max_load();
        let (min_cpu, min_load) = self.find_min_load();
        
        // Migrate threads if imbalance is significant
        if max_load &gt; min_load + IMBALANCE_THRESHOLD {
            self.migrate_threads(max_cpu, min_cpu, (max_load - min_load) / 2)?;
        }
        
        self.last_balance = now;
        Ok(())
    }
    
    /// Migrate threads between CPUs
    fn migrate_threads(&amp;self, from_cpu: CpuId, to_cpu: CpuId, count: u32) -&gt; Result&lt;()&gt; {
        let from_queue = &amp;self.cpu_queues[from_cpu];
        let to_queue = &amp;self.cpu_queues[to_cpu];
        
        for _ in 0..count {
            if let Some(thread) = from_queue.pop_migrable() {
                // Check CPU affinity
                if thread.cpu_affinity.contains(to_cpu) {
                    to_queue.push(thread);
                    
                    // Send IPI to wake up target CPU
                    send_ipi(to_cpu, IPI_RESCHEDULE);
                } else {
                    // Put back if can't migrate
                    from_queue.push(thread);
                    break;
                }
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="process-creation-and-lifecycle"><a class="header" href="#process-creation-and-lifecycle">Process Creation and Lifecycle</a></h2>
<h3 id="process-creation"><a class="header" href="#process-creation">Process Creation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Create new process with capabilities
pub fn create_process(
    binary: &amp;[u8],
    args: &amp;[&amp;str],
    env: &amp;[(&amp;str, &amp;str)],
    capabilities: &amp;[Capability],
) -&gt; Result&lt;ProcessId&gt; {
    // 1. Allocate process ID
    let pid = allocate_pid()?;
    
    // 2. Create address space
    let address_space = AddressSpace::new()?;
    
    // 3. Load binary into memory
    let entry_point = load_binary(&amp;address_space, binary)?;
    
    // 4. Set up initial stack
    let stack_base = setup_user_stack(&amp;address_space, args, env)?;
    
    // 5. Create main thread
    let main_thread = ThreadControlBlock::new(
        pid,
        entry_point,
        stack_base,
        capabilities.to_vec(),
    )?;
    
    // 6. Add to scheduler
    SCHEDULER.lock().add_thread(main_thread)?;
    
    Ok(pid)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="process-termination"><a class="header" href="#process-termination">Process Termination</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Terminate process and clean up resources
pub fn terminate_process(pid: ProcessId, exit_code: i32) -&gt; Result&lt;()&gt; {
    let process = PROCESS_TABLE.lock().get(pid)?;
    
    // 1. Terminate all threads
    for thread_id in &amp;process.threads {
        terminate_thread(*thread_id)?;
    }
    
    // 2. Notify parent process
    if let Some(parent) = process.parent {
        send_child_exit_notification(parent, pid, exit_code)?;
    }
    
    // 3. Close IPC endpoints
    for endpoint in &amp;process.ipc_endpoints {
        close_endpoint(*endpoint)?;
    }
    
    // 4. Revoke all capabilities
    for capability in &amp;process.capabilities {
        revoke_capability(capability)?;
    }
    
    // 5. Free address space
    free_address_space(process.address_space)?;
    
    // 6. Remove from process table
    PROCESS_TABLE.lock().remove(pid);
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h2>
<h3 id="benchmark-results"><a class="header" href="#benchmark-results">Benchmark Results</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Target</th><th>Achieved</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>Context Switch</strong></td><td>&lt;10μs</td><td>~8.5μs</td><td>Including TLB flush</td></tr>
<tr><td><strong>Process Creation</strong></td><td>&lt;50μs</td><td>~42μs</td><td>Basic process with minimal capabilities</td></tr>
<tr><td><strong>Thread Creation</strong></td><td>&lt;5μs</td><td>~3.2μs</td><td>Within existing process</td></tr>
<tr><td><strong>Schedule Decision</strong></td><td>&lt;1μs</td><td>~0.7μs</td><td>O(1) in most cases</td></tr>
<tr><td><strong>Load Balance</strong></td><td>&lt;100μs</td><td>~75μs</td><td>Across 8 CPU cores</td></tr>
<tr><td><strong>Wake-up Latency</strong></td><td>&lt;5μs</td><td>~4.1μs</td><td>From blocked to running</td></tr>
</tbody></table>
</div>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Process table entry
pub struct ProcessTableEntry {
    pid: ProcessId,
    parent: Option&lt;ProcessId&gt;,
    children: Vec&lt;ProcessId&gt;,
    
    // Memory footprint: ~256 bytes per process
    address_space: AddressSpace,      // 32 bytes
    capabilities: Vec&lt;Capability&gt;,    // Variable
    ipc_endpoints: Vec&lt;EndpointId&gt;,   // Variable
    threads: Vec&lt;ThreadId&gt;,           // Variable
    
    // Resource usage tracking
    memory_usage: AtomicUsize,
    cpu_time: AtomicU64,
    io_counters: IoCounters,
}

// Total overhead: ~384 bytes per thread + variable capability storage
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-architecture-support"><a class="header" href="#multi-architecture-support">Multi-Architecture Support</a></h2>
<h3 id="x86_64-specific-features"><a class="header" href="#x86_64-specific-features">x86_64 Specific Features</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "x86_64")]
impl ArchSpecific for ProcessManager {
    fn setup_syscall_entry(&amp;self, thread: &amp;mut ThreadControlBlock) -&gt; Result&lt;()&gt; {
        // Set up SYSCALL/SYSRET mechanism
        thread.saved_context.cs = KERNEL_CS;
        thread.saved_context.ss = USER_DS;
        
        // Configure LSTAR MSR for syscall entry
        unsafe {
            wrmsr(MSR_LSTAR, syscall_entry as u64);
            wrmsr(MSR_STAR, ((KERNEL_CS as u64) &lt;&lt; 32) | ((USER_CS as u64) &lt;&lt; 48));
            wrmsr(MSR_SFMASK, RFLAGS_IF); // Disable interrupts in syscalls
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="aarch64-specific-features"><a class="header" href="#aarch64-specific-features">AArch64 Specific Features</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "aarch64")]
impl ArchSpecific for ProcessManager {
    fn setup_exception_entry(&amp;self, thread: &amp;mut ThreadControlBlock) -&gt; Result&lt;()&gt; {
        // Set up exception vector table
        thread.saved_context.pstate = PSTATE_EL0;
        
        // Configure EL1 for kernel mode
        unsafe {
            write_sysreg!(vbar_el1, exception_vectors as u64);
            write_sysreg!(spsel, 1); // Use SP_EL1 in kernel mode
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="risc-v-specific-features"><a class="header" href="#risc-v-specific-features">RISC-V Specific Features</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(any(target_arch = "riscv32", target_arch = "riscv64"))]
impl ArchSpecific for ProcessManager {
    fn setup_trap_entry(&amp;self, thread: &amp;mut ThreadControlBlock) -&gt; Result&lt;()&gt; {
        // Set up trap vector
        unsafe {
            csrw!(stvec, trap_entry as usize);
            csrw!(sstatus, SSTATUS_SIE); // Enable supervisor interrupts
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-other-subsystems"><a class="header" href="#integration-with-other-subsystems">Integration with Other Subsystems</a></h2>
<h3 id="ipc-integration"><a class="header" href="#ipc-integration">IPC Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IpcIntegration for ProcessManager {
    /// Block thread waiting for IPC message
    fn block_for_ipc(&amp;self, thread_id: ThreadId, endpoint: EndpointId) -&gt; Result&lt;()&gt; {
        let mut thread = self.get_thread_mut(thread_id)?;
        thread.state = ThreadState::Blocked(BlockReason::IpcReceive(endpoint));
        
        // Remove from run queue
        SCHEDULER.lock().unschedule(thread_id)?;
        
        // Trigger reschedule
        reschedule();
        
        Ok(())
    }
    
    /// Wake thread when IPC message arrives
    fn wake_from_ipc(&amp;self, thread_id: ThreadId) -&gt; Result&lt;()&gt; {
        let mut thread = self.get_thread_mut(thread_id)?;
        thread.state = ThreadState::Ready;
        
        // Add back to run queue with priority boost
        SCHEDULER.lock().schedule_with_boost(thread_id, PRIORITY_BOOST_IPC)?;
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-management-integration"><a class="header" href="#memory-management-integration">Memory Management Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl MemoryIntegration for ProcessManager {
    /// Handle page fault for process
    fn handle_page_fault(&amp;self, thread_id: ThreadId, fault_addr: VirtAddr) -&gt; Result&lt;()&gt; {
        let thread = self.get_thread(thread_id)?;
        let process = self.get_process(thread.pid)?;
        
        // Check if address is in valid VMA
        if let Some(vma) = process.address_space.find_vma(fault_addr) {
            match vma.fault_type {
                FaultType::DemandPage =&gt; {
                    // Allocate and map new page
                    let frame = allocate_frame()?;
                    map_page(&amp;process.address_space, fault_addr, frame, vma.flags)?;
                }
                FaultType::CopyOnWrite =&gt; {
                    // Copy page and remap with write permission
                    handle_cow_fault(&amp;process.address_space, fault_addr)?;
                }
                _ =&gt; return Err(Error::SegmentationFault),
            }
        } else {
            // Invalid memory access
            terminate_thread(thread_id)?;
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<h3 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h3>
<ol>
<li><strong>Gang Scheduling</strong>: Schedule related threads together</li>
<li><strong>NUMA Awareness</strong>: Consider memory locality in scheduling decisions</li>
<li><strong>Energy Efficiency</strong>: CPU frequency scaling based on workload</li>
<li><strong>Real-Time Enhancements</strong>: Rate monotonic and deadline scheduling</li>
<li><strong>Security Enhancements</strong>: Process isolation through hardware features</li>
</ol>
<h3 id="research-areas"><a class="header" href="#research-areas">Research Areas</a></h3>
<ol>
<li><strong>Machine Learning</strong>: AI-driven scheduling optimization</li>
<li><strong>Heterogeneous Computing</strong>: GPU/accelerator integration</li>
<li><strong>Distributed Scheduling</strong>: Multi-node process migration</li>
<li><strong>Quantum Computing</strong>: Quantum process scheduling models</li>
</ol>
<p>This process management system provides the foundation for secure, efficient, and scalable computing on VeridianOS while maintaining the microkernel’s principles of isolation and capability-based security.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/memory.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/ipc.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/memory.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/ipc.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
