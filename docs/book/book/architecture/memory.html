<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memory Management - VeridianOS Developer Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive guide to VeridianOS development">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../book-theme/veridian.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VeridianOS Developer Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/doublegate/VeridianOS" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>VeridianOS implements a sophisticated memory management system designed for security, performance, and scalability. The system uses a hybrid approach combining the best aspects of different allocation strategies.</p>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The memory management subsystem consists of several key components:</p>
<ol>
<li><strong>Physical Memory Management</strong>: Frame allocator for physical pages</li>
<li><strong>Virtual Memory Management</strong>: Page table management and address spaces</li>
<li><strong>Kernel Heap</strong>: Dynamic memory allocation for kernel data structures</li>
<li><strong>Memory Zones</strong>: Specialized regions for different allocation requirements</li>
<li><strong>NUMA Support</strong>: Non-uniform memory access optimization</li>
</ol>
<h2 id="physical-memory-management"><a class="header" href="#physical-memory-management">Physical Memory Management</a></h2>
<h3 id="hybrid-frame-allocator"><a class="header" href="#hybrid-frame-allocator">Hybrid Frame Allocator</a></h3>
<p>VeridianOS uses a hybrid approach combining bitmap and buddy allocators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HybridAllocator {
    bitmap: BitmapAllocator,    // For allocations &lt; 512 frames
    buddy: BuddyAllocator,      // For allocations ≥ 512 frames
    threshold: usize,           // 512 frames = 2MB
    stats: AllocationStats,     // Performance tracking
}
<span class="boring">}</span></code></pre></pre>
<h4 id="bitmap-allocator"><a class="header" href="#bitmap-allocator">Bitmap Allocator</a></h4>
<ul>
<li>Used for small allocations (&lt; 2MB)</li>
<li>O(n) search time but low memory overhead</li>
<li>Efficient for single frame allocations</li>
<li>Simple and robust implementation</li>
</ul>
<h4 id="buddy-allocator"><a class="header" href="#buddy-allocator">Buddy Allocator</a></h4>
<ul>
<li>Used for large allocations (≥ 2MB)</li>
<li>O(log n) allocation and deallocation</li>
<li>Natural support for power-of-two sizes</li>
<li>Minimizes external fragmentation</li>
</ul>
<h3 id="numa-aware-allocation"><a class="header" href="#numa-aware-allocation">NUMA-Aware Allocation</a></h3>
<p>The allocator is NUMA-aware from the ground up:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct NumaNode {
    id: u8,
    allocator: HybridAllocator,
    distance_map: HashMap&lt;u8, u8&gt;,  // Distance to other nodes
    preferred_cpus: CpuSet,         // CPUs local to this node
}
<span class="boring">}</span></code></pre></pre>
<p>Key features:</p>
<ul>
<li>Per-node allocators for local allocation</li>
<li>Distance-aware fallback when local node is full</li>
<li>CPU affinity tracking for optimal placement</li>
<li>Support for CXL memory devices</li>
</ul>
<h3 id="reserved-memory-handling"><a class="header" href="#reserved-memory-handling">Reserved Memory Handling</a></h3>
<p>The system tracks reserved memory regions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ReservedRegion {
    start: PhysFrame,
    end: PhysFrame,
    description: &amp;'static str,
}
<span class="boring">}</span></code></pre></pre>
<p>Standard reserved regions:</p>
<ul>
<li>BIOS area (0-1MB)</li>
<li>Memory-mapped I/O regions</li>
<li>ACPI tables</li>
<li>Kernel code and data</li>
<li>Boot-time allocations</li>
</ul>
<h2 id="virtual-memory-management"><a class="header" href="#virtual-memory-management">Virtual Memory Management</a></h2>
<h3 id="page-table-management"><a class="header" href="#page-table-management">Page Table Management</a></h3>
<p>VeridianOS supports multiple page table formats:</p>
<ul>
<li><strong>x86_64</strong>: 4-level page tables (PML4 → PDPT → PD → PT)</li>
<li><strong>AArch64</strong>: 4-level page tables with configurable granule size</li>
<li><strong>RISC-V</strong>: Sv39/Sv48 modes with 3/4-level tables</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PageMapper {
    root_table: PhysFrame,
    frame_allocator: &amp;mut FrameAllocator,
    tlb_shootdown: TlbShootdown,
}
<span class="boring">}</span></code></pre></pre>
<p>Features:</p>
<ul>
<li>Automatic intermediate table creation</li>
<li>Support for huge pages (2MB, 1GB)</li>
<li>W^X enforcement (writable XOR executable)</li>
<li>Guard pages for stack overflow detection</li>
</ul>
<h3 id="address-space-management"><a class="header" href="#address-space-management">Address Space Management</a></h3>
<p>Each process has its own address space:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AddressSpace {
    page_table: PageTable,
    vmas: BTreeMap&lt;VirtAddr, Vma&gt;,  // Virtual Memory Areas
    heap_end: VirtAddr,
    stack_top: VirtAddr,
}
<span class="boring">}</span></code></pre></pre>
<p>Memory layout (x86_64):</p>
<pre><code>0x0000_0000_0000_0000 - 0x0000_7FFF_FFFF_FFFF  User space (128 TB)
0xFFFF_8000_0000_0000 - 0xFFFF_8FFF_FFFF_FFFF  Physical memory map
0xFFFF_C000_0000_0000 - 0xFFFF_CFFF_FFFF_FFFF  Kernel heap
0xFFFF_E000_0000_0000 - 0xFFFF_EFFF_FFFF_FFFF  Kernel stacks
0xFFFF_F000_0000_0000 - 0xFFFF_FFFF_FFFF_FFFF  MMIO regions
</code></pre>
<h3 id="tlb-management"><a class="header" href="#tlb-management">TLB Management</a></h3>
<p>Efficient TLB shootdown for multi-core systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TlbShootdown {
    cpu_mask: CpuMask,
    pages: Vec&lt;Page&gt;,
    mode: ShootdownMode,
}
<span class="boring">}</span></code></pre></pre>
<p>Shootdown modes:</p>
<ul>
<li><strong>Single Page</strong>: Flush specific page on target CPUs</li>
<li><strong>Range</strong>: Flush range of pages</li>
<li><strong>Global</strong>: Flush all non-global entries</li>
<li><strong>Full</strong>: Complete TLB flush</li>
</ul>
<h2 id="kernel-heap-management"><a class="header" href="#kernel-heap-management">Kernel Heap Management</a></h2>
<h3 id="slab-allocator"><a class="header" href="#slab-allocator">Slab Allocator</a></h3>
<p>The kernel uses a slab allocator for common object sizes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SlabAllocator {
    slabs: [Slab; 12],  // 8B, 16B, 32B, ..., 16KB
    large_allocator: LinkedListAllocator,
}
<span class="boring">}</span></code></pre></pre>
<p>Benefits:</p>
<ul>
<li>Reduced fragmentation</li>
<li>Fast allocation for common sizes</li>
<li>Cache-friendly memory layout</li>
<li>Per-CPU caches for scalability</li>
</ul>
<h3 id="large-object-allocator"><a class="header" href="#large-object-allocator">Large Object Allocator</a></h3>
<p>For allocations &gt; 16KB:</p>
<ul>
<li>Linked list allocator with first-fit strategy</li>
<li>Coalescing of adjacent free blocks</li>
<li>Optional debug features for leak detection</li>
</ul>
<h2 id="memory-zones"><a class="header" href="#memory-zones">Memory Zones</a></h2>
<h3 id="zone-types"><a class="header" href="#zone-types">Zone Types</a></h3>
<p>VeridianOS defines three memory zones:</p>
<ol>
<li>
<p><strong>DMA Zone</strong> (0-16MB)</p>
<ul>
<li>For legacy devices requiring low memory</li>
<li>Limited to first 16MB of physical memory</li>
<li>Special allocation constraints</li>
</ul>
</li>
<li>
<p><strong>Normal Zone</strong> (16MB-4GB on 32-bit, all memory on 64-bit)</p>
<ul>
<li>Standard allocations</li>
<li>Most kernel and user allocations</li>
<li>Default zone for most operations</li>
</ul>
</li>
<li>
<p><strong>High Zone</strong> (32-bit only, &gt;4GB)</p>
<ul>
<li>Memory above 4GB on 32-bit systems</li>
<li>Requires special mapping</li>
<li>Not present on 64-bit systems</li>
</ul>
</li>
</ol>
<h3 id="zone-balancing"><a class="header" href="#zone-balancing">Zone Balancing</a></h3>
<p>The allocator implements zone balancing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ZoneAllocator {
    zones: [Zone; MAX_ZONES],
    fallback_order: [[ZoneType; MAX_ZONES]; MAX_ZONES],
}
<span class="boring">}</span></code></pre></pre>
<p>Allocation strategy:</p>
<ol>
<li>Try preferred zone</li>
<li>Fall back to other zones if allowed</li>
<li>Reclaim memory if necessary</li>
<li>Return error if all zones exhausted</li>
</ol>
<h2 id="page-fault-handling"><a class="header" href="#page-fault-handling">Page Fault Handling</a></h2>
<h3 id="fault-types"><a class="header" href="#fault-types">Fault Types</a></h3>
<p>The page fault handler recognizes:</p>
<ul>
<li><strong>Demand Paging</strong>: First access to allocated page</li>
<li><strong>Copy-on-Write</strong>: Write to shared page</li>
<li><strong>Stack Growth</strong>: Access below stack pointer</li>
<li><strong>Invalid Access</strong>: Segmentation fault</li>
</ul>
<h3 id="fault-resolution"><a class="header" href="#fault-resolution">Fault Resolution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_page_fault(addr: VirtAddr, error_code: PageFaultError) -&gt; Result&lt;()&gt; {
    let vma = find_vma(addr)?;
    
    match vma.fault_type(addr, error_code) {
        FaultType::DemandPage =&gt; allocate_and_map(addr, vma),
        FaultType::CopyOnWrite =&gt; copy_and_remap(addr, vma),
        FaultType::StackGrowth =&gt; extend_stack(addr, vma),
        FaultType::Invalid =&gt; Err(Error::SegmentationFault),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimizations"><a class="header" href="#performance-optimizations">Performance Optimizations</a></h2>
<h3 id="allocation-performance"><a class="header" href="#allocation-performance">Allocation Performance</a></h3>
<p>Achieved performance metrics:</p>
<ul>
<li>Frame allocation: ~500ns average</li>
<li>Page mapping: ~1.5μs including TLB flush</li>
<li>Heap allocation: ~350ns for slab sizes</li>
<li>TLB shootdown: ~4.2μs per CPU</li>
</ul>
<h3 id="optimization-techniques"><a class="header" href="#optimization-techniques">Optimization Techniques</a></h3>
<ol>
<li><strong>Per-CPU Caches</strong>: Reduce lock contention</li>
<li><strong>Batch Operations</strong>: Allocate multiple frames at once</li>
<li><strong>Lazy TLB Flushing</strong>: Defer flushes when possible</li>
<li><strong>NUMA Locality</strong>: Prefer local memory allocation</li>
<li><strong>Huge Pages</strong>: Reduce TLB pressure</li>
</ol>
<h2 id="security-features"><a class="header" href="#security-features">Security Features</a></h2>
<h3 id="memory-protection"><a class="header" href="#memory-protection">Memory Protection</a></h3>
<ul>
<li><strong>W^X Enforcement</strong>: Pages cannot be writable and executable</li>
<li><strong>ASLR</strong>: Address space layout randomization</li>
<li><strong>Guard Pages</strong>: Detect buffer overflows</li>
<li><strong>Zeroing</strong>: Clear pages before reuse</li>
</ul>
<h3 id="hardware-features"><a class="header" href="#hardware-features">Hardware Features</a></h3>
<p>Support for modern hardware security:</p>
<ul>
<li>Intel CET (Control-flow Enforcement Technology)</li>
<li>ARM Pointer Authentication</li>
<li>Memory tagging (MTE/LAM)</li>
<li>Encrypted memory (TDX/SEV)</li>
</ul>
<h2 id="future-enhancements"><a class="header" href="#future-enhancements">Future Enhancements</a></h2>
<h3 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h3>
<ol>
<li><strong>Memory Compression</strong>: Transparent page compression</li>
<li><strong>Memory Deduplication</strong>: Share identical pages</li>
<li><strong>Persistent Memory</strong>: Support for NVDIMM devices</li>
<li><strong>Memory Hot-Plug</strong>: Dynamic memory addition</li>
<li><strong>CXL Support</strong>: Compute Express Link memory</li>
</ol>
<h3 id="research-areas"><a class="header" href="#research-areas">Research Areas</a></h3>
<ul>
<li>Machine learning for allocation prediction</li>
<li>Quantum-resistant memory encryption</li>
<li>Hardware-accelerated memory operations</li>
<li>Energy-aware memory management</li>
</ul>
<h2 id="api-examples"><a class="header" href="#api-examples">API Examples</a></h2>
<h3 id="kernel-api"><a class="header" href="#kernel-api">Kernel API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Allocate physical frame
let frame = FRAME_ALLOCATOR.lock().allocate()?;

// Map page with specific permissions
page_mapper.map_page(
    Page::containing_address(virt_addr),
    frame,
    PageFlags::PRESENT | PageFlags::WRITABLE | PageFlags::USER,
)?;

// Allocate from specific zone
let dma_frame = zone_allocator.allocate_from_zone(
    ZoneType::DMA,
    order,
)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="user-space-api"><a class="header" href="#user-space-api">User Space API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Memory mapping
let addr = mmap(
    None,                    // Any address
    4096,                    // Size
    PROT_READ | PROT_WRITE,  // Permissions
    MAP_PRIVATE | MAP_ANON,  // Flags
)?;

// Memory protection
mprotect(addr, 4096, PROT_READ)?;

// Memory unmapping
munmap(addr, 4096)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-support"><a class="header" href="#debugging-support">Debugging Support</a></h2>
<h3 id="memory-debugging-tools"><a class="header" href="#memory-debugging-tools">Memory Debugging Tools</a></h3>
<ol>
<li><strong>Allocation Tracking</strong>: Track all allocations with backtraces</li>
<li><strong>Leak Detection</strong>: Find unreleased memory</li>
<li><strong>Corruption Detection</strong>: Guard bytes and checksums</li>
<li><strong>Statistics</strong>: Detailed allocation statistics</li>
</ol>
<h3 id="debug-commands"><a class="header" href="#debug-commands">Debug Commands</a></h3>
<pre><code class="language-bash"># Show memory statistics
echo mem &gt; /sys/kernel/debug/memory

# Dump page tables
echo "dump_pt 0x1000" &gt; /sys/kernel/debug/memory

# Show NUMA topology
cat /sys/devices/system/node/node*/meminfo
</code></pre>
<p>The memory management system is designed to be robust, efficient, and secure, providing a solid foundation for the rest of the VeridianOS kernel.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/microkernel.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/processes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/microkernel.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/processes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
